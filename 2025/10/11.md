### 取り組んだこと課題一覧
- REST
- Django
### わかったこと
-  WebAPIをデータを利活用してもらうために公開している
- 1番の問題は入るはずの利益が入らなくなること
- リスクと対策
	- 他のAPIサービスで優れているものがあり、自分たちが作成したAPIよりそっちが選ばれてしまう状況だとユーザが減ってしまう原因になる。対策としてはユーザーにとって良い機能を作成して追加する
	- 自分たちのAPIサービスを利用しているサービスが良くない評判だった場合、自分たちのAPIサービスまで評判が下がってしまう可能性がある。対策はそういった低レベルのサービスに対しては、自分たちのAPIの使用を停止する
	- API化することで、機械的にデータを取得しやすくなるので、リソースが圧迫される可能性がある。対策はデータを取得しすぎている該当サービスに対してAPIの利用制限をかける。(利用制限をかけることレートリミットという)

-  HTTPレスポンスの構成
	- ステータスライン
		- HTTPバージョン、ステータスコード、フレーズ
	- ヘッダー
		- ステータスラインで表現できないメタ情報が入る
	- ボディー
		- 任意のデータを入れられる

-  REST原則
	- クライアント/サーバー
	- 階層化システム
		- メリット：各システム(コンポーネント)に役割を決めて、独立させることで進化と再利用が促進できる
		- デメリット：処理にオーバーヘッドが発生。つまりユーザーから見ると応答が悪く見える
			- キャッシュを利用することで改善が見込める
	- コードオンデマンド
		- クライアントコードをダウンロードして実行できる
			- リリース後にクライアントコードを変更できる
			- メリット：リリース済みのクライアントに対して機能追加ができる。また、サーバーの負荷が下がる。(クライアントに処理が移譲できるため)
			- デメリット：評価環境が複雑になる
	- 統一インターフェース
		- リソースの識別
			- URIを用いてサーバーに保存されたデータを識別する
			- リソースとは名前がつけられたあらゆるもの
		- 表現を用いたリソース操作
			- 断面情報を利用してサーバー上のデータを操作する
				- リソースのある断面が「表現」
				- クライアントからサーバーへ編集リクエストする際、認証情報等のメタ情報を付与する
		- 自己記述メッセージ
			- レスポンスのヘッダーに含まれるメタ情報で、内容がどのようなものかわかる
		- アプリケーション状態エンジンとしてハイパーメディア(HATEOAS)
			- メリット1：システムアーキテクチャ全体が簡素化されてわかりやすくなる
			- メリット2：提供するサービスに集中でき、独自の進化ができる
			- メリット3：異なるブラウザでも同じような画面を表示できる
			- デメリット：標準化によって効率が犠牲になる

-  API設計レベル（4段階ある）
- レベル0：HTTPを使っている
	- HTTPは単なる通信手段として利用
	- 1URLで全て完結
	- リクエストボディーに処理と引数が含まれる
- レベル1：リソースの概念を導入
	- リソースごとにURLを分割
	- HTTPメソッドは活用できていないのでGETかPOSTのみで通信
- レベル2：HTTPの動詞を導入
	- リソースに対してHTTPメソッドを使ったCRUD操作が行われている
- レベル3：HATEOASの概念を導入
	- LEVEL2に加えて、レスポンスにリソース間のつながりが含まれる
	- レスポンスに現在の状態に関連するハイパーリンクが含まれている（＝HATEOASに相当する情報がレスポンスに含まれている）
  
- URIの設計で考慮すること
	- 短く入力しやすい
		- 冗長なパスを含まない
	- 人間が読んで理解出来る
		- 無意味に略したりして、自分以外が見てわからない言葉を使わない
	- 大文字小文字が混雑していない
		- 一般的には小文字のみ
	- 単語はハイフンで繋げる
		- アンダースコアは繋げるためには使わない
	- 単語は複数形を利用する
		- ✖️：user/123
		- ○：users/123
	- エンコードを必要とする文字を利用しない
	- サーバー側のアーキテクチャが反映されていない
		- 使用している言語などの名前をURIに含めないなど、構成要素を描かない方がいい
	- 改造しやすい（Hackble）
		- URIにサーバーの名前などの情報を含めない
	- ルールが統一されている
		- クエリパラメータ、もしくはパスパラメータのどちらかに統一して書くなど、全体に統一性を持たせる

-  HTTPメソッドとURI
	- HTTPリクエストのリクエストラインのリソースでアクセスしたURLがわかる。そしてその前にGETやPOSTなどのHTTPメソッドが付いているので、アクセスしたURLに対してどういうことをしたかったのかが読み取れる

- クエリパラメータ
	- URLの末尾にある？(はてな)の後ろに続いているキーバリュー
	- 省略可能かどうか→クエリパラメータを使用
- パスパラメータ
	- URL中に埋め込まれるパラメーター。見た目はフォルダ等のパス表示と同じでスラッシュで区切られる
	- 一意なリソースを表すのに必要かどうか→パスパラメータを使用


- データフォーマット
	- XML
	- JSON
	- JSONP

- レスポンスのデータの内部構成について
	- エンベロープは使わない
		- エンベロープとは、レスポンスボディー内に含まれているメタ情報。ヘッダー情報と役割が被るのでエンベロープは使わない。必要な情報だけ書くことを心がける。
	- オブジェクトはできるだけフラットにする
		- オブジェクトはネストできるが、そうすると容量が増えてしまうので、レスポンス容量を減らすためにできるだけフラットにしたほうが良い。必要な情報だけ書くことを心がける。
	- ページネーションをサポートする情報を返す
	- プロパティの命名規則はAPI全体で統一する
		- スネークケース：snake_case
		- キャメルケース：camelCase
		- パスカルケース：PascalCase（あまり見かけない）
	- 日付はRFC3339 (W3C-DTF)形式を使う
	- 大きな数字(64bit整数)は文字列で返す

- エラーを設計する際の表現について
	- エラー詳細はレスポンスボディーに入れる
		- 例えば400 Bad Requestだけ返ってきても理由がわからないので、理由をレスポンスボディーに記載する
	- エラーの際にHTMLが返らないようにする
		- APIを叩いて返ってくる情報で期待している記述の内容はJSON形式が一般的。なのにHTMLが返ってくるのは良くないし、レスポンスフォーマットが変わると、クライアントアプリ側で処理できないケースがある
	- サービス閉塞時は"503"+"Retry-After"
		- 503 Service TemporaryのステータスコードとレスポンスボディにRetry-Afterでいつ頃再開見込みかを記載する

-  APIのバージョン
	- メリット：特定バージョン指定でアクセスできるので、クライアント側で突然エラーにはならない
	- デメリット：複数バージョンを並列稼働させるため、ソースコードやデータベースの管理が複雑になる
	- バージョンを入れられる場所はパス、クエリ、ヘッダーの3種類があるが、実例としてはパスが最も多い
	- マイナーアップデートも含めると管理が大変になってしまうため、メジャーアップデートのみで管理しておく方が管理が楽

- 認証と認可
	- 認証は「本人特定」、認可は「アクセス制御」

- レートリミット
- 30回/10分のレートリミットの場合
	- Fixed Window
		- 例えば、最初の10分枠のうち、最初の2分で30回のアクセスがあった場合、残りの8分はアクセスが不可になる
		- 合計の10分間が終われば、アクセス数がリセットされて、再度アクセス可能になる10分枠が始まる。
		- 問題点としては、最初の10分枠の9分位でアクセスが一気に1から30まで行ったとして、次の10分枠が始まって、すぐに30回もなアクセスがあった場合、枠は別だが、その3、4分の間に60回分のアクセスがあったと見ることができるので、良い設計と判断できるかは今の俺にはわからない
	- Sliding Log
		- 10分の枠がスライドして行って、30回のアクセスが計算される。
		- 過去のアクセスはログが残るのでスライドしていって、アクセス数が30回未満になればまた新たなアクセスが可能になる
		- 問題点は、ログが大量に残るのでログの破棄を考える必要がある
	- Sliding Window
		- 上の2つを合わせたような感じだったが、特にログが溜まるわけでもなくアクセス時間に対して前の時間のアクセス数の計算をしていたような感じ。あまりわからなかったので割愛

- セキュリティ
	- XSS
		- 悪意あるユーザーが正規のサイドに不正なスクリプトを挿入することで、正規ユーザーの情報を不正に引き出したり操作できてしまう問題
			- 対策はレスポンスヘッダーの追加
	- CSRF
		- 本来拒否しなければいけないアクセス元(許可しないアクセス元)からリクエストを処理してしまう問題
			- 対策は許可しないアクセス元からのリクエストを拒否
			- もう一つは、攻撃者に推測されにくいトークンの発行/総合処理を実装
	- HTTP
		- 通信経度が暗号化されないので盗聴されやすい
			- 対策は、常時HTTPSを利用した通信にする
	- JSON Web Token(JWT)
		- クライアント側で内容の確認/編集が簡単にできるため、サーバー側の検証が不十分だと改ざんされた情報を正規として受け入れてしまう
			- 対策はヘッダーのalfに"none"以外を指定して署名を暗号化する
			- もう一つは、ペイロードのaudに想定する利用者を指定して受診時に検証する
- Djangoのインストール方法
### 次やること
- REST  SQLの復習
### 感じたこと
- DjangoはProgateでやったRubyonRailsに似ていた
### 学習時間
#### プログラミング
- 今日：9h 合計：712.75h
#### 英語
- 今日：0h 合計：53.75h